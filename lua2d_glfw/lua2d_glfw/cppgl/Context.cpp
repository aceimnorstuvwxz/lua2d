//
//  Context.cpp
//  lua2d_glfw
//
//  Created by chenbingfeng on 15/5/2.
//  Copyright (c) 2015å¹´ chenbingfeng. All rights reserved.
//

#include "Context.h"
#include <sys/time.h>
#include <chrono>
#include <thread>

NS_CPPGL_BEGIN

//void activate();
//void setVertifcalSync(bool enabled);

void Context::enable(Capability::capability_t capability)
{
    glEnable(capability);
}

void Context::disable(Capability::capability_t capability)
{
    glDisable(capability);
}

void Context::clearColor(const Color& col)
{
    glClearColor(col.r, col.g, col.b, col.a);
}

void Context::clear(Buffer::buffer_t buffers)
{
    glClear(buffers);
}

void Context::blendFunc(BlendFactor::blend_factor_t sfactor, BlendFactor::blend_factor_t dfactor)
{
    glBlendFunc(sfactor, dfactor);
}

void Context::depthMask(bool writeEnabled)
{
    glDepthMask(writeEnabled);
}

void Context::stencilMask(bool writeEnabled)
{
    glStencilMask(writeEnabled);
}
void Context::stencilMask(unsigned int mask)
{
    glStencilMask(mask);
}

void Context::stencilFunc(TestFunction::test_function_t function, int reference, unsigned int mask)
{
    glStencilFunc(function, reference, mask);
}
void Context::stencilOp(StencilAction::stencil_action_t fail, StencilAction::stencil_action_t zfail, StencilAction::stencil_action_t pass)
{
    glStencilOp(fail, zfail, pass);
}

void Context::useProgram( const Program& program)
{
    glUseProgram(program);
}

void Context::bindTexture(const Texture& texture, unsigned char unit)
{
    glActiveTexture(GL_TEXTURE0 + unit);
    glBindTexture(GL_TEXTURE_2D, texture);
}

void Context::bindFramebuffer( const Framebuffer& framebuffer)
{
    glBindFramebuffer(GL_DRAW_FRAMEBUFFER, framebuffer);

    // set viewport to frame buffer size
    GLint obj, width, height;
    glGetFramebufferAttachmentParameteriv(GL_DRAW_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME, &obj);

    GLint res;
    glGetIntegerv(GL_TEXTURE_BINDING_2D, &res);
    glBindTexture(GL_TEXTURE_2D, obj);
    glGetTexLevelParameteriv(GL_TEXTURE_2D, 0, GL_TEXTURE_WIDTH, &width);
    glGetTexLevelParameteriv(GL_TEXTURE_2D, 9, GL_TEXTURE_HEIGHT, &height);
    glBindTexture(GL_TEXTURE_2D, res);

    glViewport(0, 0, width, height);
}
void Context::bindFramebuffer()
{
    glBindFramebuffer(GL_DRAW_FRAMEBUFFER, 0);

    glViewport(defaultViewport[0], defaultViewport[1], defaultViewport[2], defaultViewport[3]);
}

void Context::beginTransformFeedback( Primitive::primitive_t mode)
{
    glBeginTransformFeedback(mode);
}
void Context::endTransformFeedback()
{
    glEndTransformFeedback();
}

void Context::drawArrays(const VertexArray& vao, Primitive::primitive_t mode, unsigned int offset, unsigned int count)
{
    glBindVertexArray(vao);
    glDrawArrays(mode, offset, count);
}
void Context::drawElements(const VertexArray& vao, Primitive::primitive_t mode, intptr_t offset, unsigned int count, unsigned int type)
{
    glBindVertexArray(vao);
    glDrawElements(mode, count,  type, (const GLvoid*)offset);
}

//float Context::time()
//{
//    timeval time;
//    gettimeofday( &time, NULL );
//
//    return time.tv_sec - timeOffset.tv_sec + ( time.tv_usec - timeOffset.tv_usec ) / 1000000.0f;
//}
long Context::getCurrentMicroseconds()
{
//    auto tp = std::chrono::steady_clock::now();
    return 0;
}

void Context::sleepMicroseconds(long microseconds)
{

}


Context Context::useExistingContext()
{
    return Context();
}

Context::~Context()
{
}

Context::Context()
{
    // always using external context,
    // generally the context is generated by
    // GLFW.

    // do nothing!
}
//Context::Context(unsigned char color, unsigned char depth, unsigned char stencil, unsigned int antialias)
//{
//    // Load OpenGL extensions
////    loadExtensions();
//
//}


NS_CPPGL_END